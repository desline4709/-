# <center>现代程序设计作业2</center>

## <center>情绪分析</center>

### 一、任务要求

- 数据清洗
- 对一条微博进行情绪分析
- 通过参数控制并返回对应情绪的时间模式
- 通过参数控制并返回对应情绪的空间分布
- 字典方法进行情绪理解的优缺点
- 对情绪的时间和空间分布进行可视化
- 情绪时空模式的管理意义

### 二、任务分块实现情况

本次作业使用函数进行封装，不同任务模块对应不同的函数。

#### 0. 所需模块

```python
import jieba
import re
import numpy as np
import time
from geopy.distance import geodesic
from matplotlib import pyplot as plt
```

#### 1. 数据加载

封装一个可以加载本地文件的函数进行微博数据和停用词表的加载

```python
def load_data(path, mode=0):
    """
    加载本地数据，只读取txt文本
    :param path: 文件相对位置
    :param mode: 加载文件的模式，0表示正常按行读取，1表示读取后的结果每条去掉末尾的换行符
    :return: 数据列表
    """
    with open(path, 'r', encoding='utf-8') as f:
        if mode == 0:
            data = f.readlines()
        elif mode == 1:
            data = f.read().split()
        else:
            raise Exception('Error mode')
    return data
```

#### 2. 数据清洗

将数据清洗分为以下三个模块封装成函数后，实现数据清洗

##### （1）去除噪声（urls）

通过正则表达式匹配出文本中url的位置，然后将其后的部分去除，得到无噪声的文本

```python
    def remove_urls(wb_data):
        """
        去除微博文本中的URL
        :param wb_data: 微博元数据
        :return: 去除url后的微博数据
        """
        temp = []
        for wb in wb_data:
            try:
                end_index = re.search(r'https?://([\w-]+\.)+[\w-]+(/[\w./?%&=]*)?', wb).span()[0]  # 找到url的起始位置
                temp.append(wb[:end_index])
            except AttributeError:
                temp.append(wb)
        return temp
```

##### （2）分词

利用jieba库内置的函数进行文本分词，同时为了更好地保留情绪标志词，要导入对应的情绪词典

```python
def cutting(wb_data):
    """
    将微博数据进行分词
    :param wb_data: 微博元数据
    :return: 分词后的二维列表
    """

    def init():
        # 加载情绪词典
        jieba.load_userdict("emotion dict\\anger.txt")
        jieba.load_userdict("emotion dict\\disgust.txt")
        jieba.load_userdict("emotion dict\\fear.txt")
        jieba.load_userdict("emotion dict\\joy.txt")
        jieba.load_userdict("emotion dict\\sadness.txt")

    init()
    split_list = []
    for wb in wb_data:
        split_list += [jieba.lcut(wb)]
    return split_list
```

##### （3）过滤停用词

通过停用词表，将分词结果中的停用词过滤掉，得到清洗后的分词结果

```python
    def filtering(wordlist):
        """
        过滤停用词
        :param wordlist: 一条微博的分词列表
        :return: 过滤停用词后的分词列表
        """
        temp = []
        for i in wordlist:
            if i not in stopwords_list:
                temp += [i]
        # print(temp)
        return temp
```

##### （4）本模块全过程

```python
def clean(wb_data, sw_data):
    """
    本函数进行微博语句的清洗
    :param wb_data: 微博分词数据
    :param sw_data: 停用词表
    :return:返回清洗后的分词情况
    """

    def cutting(wb_data):
        """
        将微博数据进行分词
        :param wb_data: 微博元数据
        :return: 分词后的二维列表
        """

        def init():
            # 加载情绪词典
            jieba.load_userdict("emotion dict\\anger.txt")
            jieba.load_userdict("emotion dict\\disgust.txt")
            jieba.load_userdict("emotion dict\\fear.txt")
            jieba.load_userdict("emotion dict\\joy.txt")
            jieba.load_userdict("emotion dict\\sadness.txt")

        init()
        split_list = []
        for wb in wb_data:
            split_list += [jieba.lcut(wb)]
        return split_list

    def remove_urls(wb_data):
        """
        去除微博文本中的URL
        :param wb_data: 微博元数据
        :return: 去除url后的微博数据
        """
        temp = []
        for wb in wb_data:
            try:
                end_index = re.search(r'https?://([\w-]+\.)+[\w-]+(/[\w./?%&=]*)?', wb).span()[0]  # 找到url的起始位置
                temp.append(wb[:end_index])
            except AttributeError:
                temp.append(wb)
        return temp

    def filtering(wordlist):
        """
        过滤停用词
        :param wordlist: 一条微博的分词列表
        :return: 过滤停用词后的分词列表
        """
        temp = []
        for i in wordlist:
            if i not in stopwords_list:
                temp += [i]
        # print(temp)
        return temp

    # 初始化数据结构
    split_list_filtered = []
    stopwords_list = sw_data
    wb_no_urls = remove_urls(wb_data)
    split_list = cutting(wb_no_urls)
    for i in split_list:
        y = filtering(i)
        split_list_filtered += [y]
    # print(split_list_filtered)
    return split_list_filtered
```

得到清洗后的分词结果部分展示：

![清洗后](D:\大学\大二到大四\大三上\现代程序设计\作业\week3\清洗后.png)

#### 3. 情绪分析

- 闭包实现

- 两种计量情绪的方法vector和value

  vector是用情绪词的比例向量直接作为当前一条微博的情绪，value是以比例最大情绪词为主情绪，若出现多个主情绪，则认为是混合情感的（mixed），如果所有情绪比例一致（包括全是0），认为无明显情绪（plain）

由此这个部分的功能由两个函数实现，第一个函数使用闭包加载情绪词典并对一条博文进行情感分析，返回本条博文的情感结果（一个向量或一个元组，分别对应不同的方式）；第二个函数利用第一个函数进行所有博文的情感分析，得到情感标签的列表。

其中flag指的是大的情绪分类 ，分为单一情绪(single)，混合情绪(mixed)，无明显情绪(plain)。

```python
def emotion_analysing(method):
    """
    进行情感分析，传入分词后的结果以及使用的情感分析方法，其中每条微博分词后的结果应该是一维列表，
    :param method: method分为"vector"和"value"，对应返回的是情绪值还是情绪向量
    其中在外层函数传入method控制使用的内层函数，在内层函数传入分词结果
    :return:情感分析结果
    """
    anger_dict = load_data("emotion dict\\anger.txt", 2)
    disgust_dict = load_data("emotion dict\\disgust.txt", 2)
    fear_dict = load_data("emotion dict\\fear.txt", 2)
    joy_dict = load_data("emotion dict\\joy.txt", 2)
    sadness_dict = load_data("emotion dict\\sadness.txt", 2)
    # print(anger_dict)

    def vector(wordlist):
        """
        返回情绪向量的方法，情绪向量的构成为 (anger, disgust, fear, joy, sadness)

        :return: 返回情绪向量，表示每个情绪词的个数比例
        """
        num_vec = [0 for i in range(5)]
        for word in wordlist:
            # print(word)
            if word in anger_dict:
                num_vec[0] += anger_dict[word]
            elif word in disgust_dict:
                num_vec[1] += disgust_dict[word]
            elif word in fear_dict:
                num_vec[2] += fear_dict[word]
            elif word in joy_dict:
                num_vec[3] += joy_dict[word]
            elif word in sadness_dict:
                num_vec[4] += sadness_dict[word]
        num_total = sum(num_vec)
        if num_total == 0:
            res = num_vec
        else:
            res = [(i/num_total) for i in num_vec]
        return res

    def value(wordlist):
        """
        返回情绪值（字符串）的方法，情绪向量的构成为 (anger, disgust, fear, joy, sadness)

        :return: 返回情绪向量，表示每个情绪词的个数比例
        """
        rate_vec = vector(wordlist)
        em_flag = ['single', 'mixed', 'plain']  # 单一情绪，多情绪混合，无显著情绪
        em_tag = ['angry', 'disgusting', 'fear', 'joy', 'sad']  # 详细的情绪标签
        if max(rate_vec) == min(rate_vec):
            # 最大和最小相同（已经包括全是0的情况），表示无显著情绪
            res = (em_flag[2], -1)
        elif rate_vec.count(max(rate_vec)) >1 :
            # 出现重复的最大值时，混合情绪
            res = (em_flag[1], -1)
        else:
            # 有独立最大值，单一情绪
            res = (em_flag[0], em_tag[rate_vec.index(max(rate_vec))])
        return res

    if method == 'vector':
        return vector
    elif method == 'value':
        return value
```

```python
def emotion_tagging(wb_data, method):
    """
    给每条微博数据进行情绪标记
    :param wb_data: 微博数据列表
    :param method: 采用的情绪判定方法，'vector'或'value'
    :return: 返回情绪标记列表
    """
    res = []
    em_analysing = emotion_analysing(method)
    for i in wb_data:
        tag = em_analysing(i)
        res.append(tag)
    return res
```

vector法得到的情绪结果：

![vector法得到的tag](D:\大学\大二到大四\大三上\现代程序设计\作业\week3\vector法得到的tag.png)

value法得到的情绪结果：

![value法得到的tag](D:\大学\大二到大四\大三上\现代程序设计\作业\week3\value法得到的tag.png)

#### 4. 时间模式分析

##### （1）提取时间信息

通过正则表达式和时间戳技术完成本部分的任务：通过正则表达式匹配出博文中的时间信息，再根据其编码形式还原成时间戳并记录到列表中，从而得到博文时间信息的列表

```python
def extract_time(wb_data):
    """
    提取时间信息
    :param wb_data: 微博元数据
    :return: 时间戳的列表
    """
    timetick_list = []
    re_str = '(?P<week>\w{3}) (?P<mon>\w{3}) (?P<day>\d+) (?P<time>\d+:\d+:\d+) (?P<zone>\+\d+) (?P<year>\d{4})'
    for wb in wb_data:
        totaltime_str = re.search(re_str, wb)
        timetick_list.append(time.mktime(time.strptime(totaltime_str.group(),"%a %b %d %H:%M:%S %z %Y")))
    return timetick_list
```

##### （2）在指定时间模式下分析

根据对所有博文时间的分析，我发现，所有博文涵盖的时间范围一共只有3天，共49个小时，因此设定了三个模式进行情绪分析：分别是小时(hour)模式、固定时段(fixed)模式和天(day)模式。小时模式（或天模式）是统计距离设定时间起点每小时（或每天）内的情绪比例，而固定时段模式是统计3天中固定时间段中的情绪比例。

```python
def emotion_time_distribute(wbemo_tag, time_list, mood, timemode, method):
    """
    传入标签列表并制定返回模式，返回对应情绪的指定模式，经分析，微博数据时间分布从2013.10.11零点-2013.10.13零点共两天的时间
    :param wbemo_tag:微博情绪标签列表
    :param mood: 情绪，包括 'angry', 'disgusting', 'fear', 'joy', 'sad', 'all'（输出所有的情绪比例变化趋势）
    :param timemode: 控制返回的模式，包括小时(hour--0)、固定时段(fixed--1)、天(day--2)等
    :param method: 指定计量情绪的方法，'vector' 或 'value'
    :return: 对应情绪的指定模式
    """
    start_str = '2013 Oct 11 00:00:00'  # 开始时间
    end_str = '2013 Oct 13 01:00:00'  # 结束时间
    start_tick = time.mktime(time.strptime(start_str, "%Y %b %d %X"))  # 转换为时间戳
    end_tick = time.mktime(time.strptime(end_str, "%Y %b %d %X"))
    hour_num = int((end_tick - start_tick) // 3600)  # 一共几个小时
    em_flag = ['single', 'mixed', 'plain']  # 单一情绪，多情绪混合，无显著情绪
    em_flag_cot = [0 for i in range(len(em_flag))]  # flag计数器
    em_tag = ['angry', 'disgusting', 'fear', 'joy', 'sad']  # 详细的情绪标签
    em_tag_cot = np.zeros(len(em_tag))
    em_flag_cot_arr = [np.zeros(len(em_flag) * hour_num).reshape((hour_num, len(em_flag))),
                       np.zeros(len(em_flag) * 24).reshape((24, len(em_flag))),
                       np.zeros(len(em_flag) * 3).reshape((3, len(em_flag)))]  # 分别代表3种模式的计数器，3维数组
    em_tag_cot_arr = [np.zeros(len(em_tag) * 49).reshape((49, len(em_tag))),
                       np.zeros(len(em_tag) * 24).reshape((24, len(em_tag))),
                       np.zeros(len(em_tag) * 3).reshape((3, len(em_tag)))]
    em_vecnum_arr = [np.zeros(hour_num), np.zeros(24), np.zeros(3)]  # 每个模式下对应向量的计数器
    em_tagnum = 0  # 计算非零的向量标签总数

    def vector():
        nonlocal em_tag_cot, em_flag_cot, em_tagnum
        for i in range(len(wbemo_tag)):
            # vector计量情绪，只有情绪比例;wbemo_tag是二维列表
            em_tag_cot += np.array(wbemo_tag[i])
            try:
                if timemode == 0:
                    time_index = int((time_list[i] - start_tick) //3600)
                elif timemode == 1:
                    time_index = int(time.strftime("%H", time.localtime(time_list[i])))
                elif timemode == 2:
                    time_index = int((time_list[i] - start_tick) // (3600*24))
                em_tag_cot_arr[timemode][time_index] += np.array(wbemo_tag[i])
                if np.sum(wbemo_tag[i]) != 0:
                    em_vecnum_arr[timemode][time_index] += 1
                    em_tagnum += 1
            except NameError:
                raise Exception('No time_index')
            except IndexError:
                raise Exception('Wrong index')
        em_tag_cot = em_tag_cot / em_tagnum  # 总的情绪比例
        # print(np.sum(em_tag_cot_arr[timemode]))
        # print(np.sum(em_vecnum_arr[timemode]))
        # print(em_tagnum, em_tag_cot)
        try:
            if timemode == 0:
                num_of_index = hour_num
            elif timemode == 1:
                num_of_index = 24
            elif timemode == 2:
                num_of_index = 3
            res = []
            for hour in range(num_of_index):
                em_tag_cot_arr[timemode][hour] /= em_vecnum_arr[timemode][hour]
                if mood != 'all':
                    tag_index = em_tag.index(mood)
                    res.append(em_tag_cot_arr[timemode][hour][tag_index])
                else:
                    res.append(em_tag_cot_arr[timemode][hour])
        except:
            raise Exception('No num_of_index')

        return [em_tag_cot, res]

    def value():
        nonlocal em_tag_cot, em_flag_cot, em_tagnum
        for i in range(len(wbemo_tag)):
            # value计量情绪，只有一个情绪标签;wbemo_tag是元组的列表，元组第0位是em_flag，第1位是em_tag
            flag_index = em_flag.index(wbemo_tag[i][0])
            em_flag_cot[flag_index] += 1
            if wbemo_tag[i][1] != -1:
                # 单一情绪
                tag_index = em_tag.index(wbemo_tag[i][1])
                em_tag_cot[tag_index] += 1
                try:
                    if timemode == 0:
                        time_index = int((time_list[i] - start_tick) // 3600)
                    elif timemode == 1:
                        time_index = int(time.strftime("%H", time.localtime(time_list[i])))
                    elif timemode == 2:
                        time_index = int((time_list[i] - start_tick) // (3600 * 24))
                    em_tag_cot_arr[timemode][time_index][tag_index] += 1
                    # if np.sum(wbemo_tag[i]) != 0:
                    #     em_vecnum_arr[timemode][time_index] += 1
                    #     em_tagnum += 1
                except NameError:
                    raise Exception('No time_index')
                except IndexError:
                    raise Exception('Wrong index')
        em_tag_cot /= np.sum(em_tag_cot)  # 总的单一情绪的情绪比例
        em_flag_cot /= np.sum(em_flag_cot)  # 总的情绪flag的比例
        try:
            if timemode == 0:
                num_of_index = hour_num
            elif timemode == 1:
                num_of_index = 24
            elif timemode == 2:
                num_of_index = 3
            res = []
            for hour in range(num_of_index):
                em_tag_cot_arr[timemode][hour] /= np.sum(em_tag_cot_arr[timemode][hour])
                if mood != 'all':
                    tag_index = em_tag.index(mood)
                    res.append(em_tag_cot_arr[timemode][hour][tag_index])
                else:
                    res.append(em_tag_cot_arr[timemode][hour])
        except:
            raise Exception('No num_of_index')
        return [em_flag_cot, em_tag_cot, res]

    if method == 'vector':
        return vector
    elif method == 'value':
        return value
```

为方便下文进行画图使用，因此本函数也做成闭包的形式，可以直接在main中调用获取情绪时间模式的信息，也可以用后文提供的封装好的函数在获取信息的同时得到图像。

例——value法得到的angry小时模式结果：

![value法得到的angry小时模式](D:\大学\大二到大四\大三上\现代程序设计\作业\week3\value法得到的angry小时模式.png)

#### 5. 空间分析

##### （1）提取空间信息

通过正则表达式以及分组的方式获取博文中的经纬度坐标，组成元组并放入列表输出

```python
def extract_area(wb_data):
    """
    提取地点信息
    :param wb_data: 微博元数据
    :return: 地点信息
    """
    location_list = []
    re_str = '\[(?P<lat>\d.*), (?P<lng>\d.*)\]'  # lat纬度, lng经度
    for wb in wb_data:
        r = re.search(re_str, wb)
        lat = eval(r.group('lat'))
        lng = eval(r.group('lng'))
        location_list.append((lat, lng))
    return location_list
```

##### （2）进行空间分析

通过分析得到，所有博文的分布范围不超过北京市，因此将北京市中心（故宫博物院）的经纬度坐标设定为中心点，间隔1

km扩散直至半径囊括所有的博文发布位置位置，分析半径范围内的情绪变化状况。

```python
def emotion_location_distribute(wbemo_tag, area_list, mood, method):
    """
    传入标签列表和坐标列表并返回情绪比例随与中心点距离变化的趋势
    :param wbemo_tag: 情绪标签列表
    :param area_list: 坐标元组列表
    :param mood: 指定的情绪
    :param method: 情绪计量的方式
    :return: 情绪比例随与中心点距离变化的趋势
    """
    # 经考察，本微博数据的地点范围主要在北京市范围内，因此以北京市的故宫博物院的位置作为中心点
    center_location = (39.924055, 116.403424) # 纬度，经度
    dis_list = []
    for i in range(len(wbemo_tag)):
        dis = geodesic(center_location, area_list[i]).km
        dis_list.append(dis)
    max_dis = int(max(dis_list)) +1  # 最远距离
    radium = [i for i in range(1, max_dis+1)]
    em_flag = ['single', 'mixed', 'plain']  # 单一情绪，多情绪混合，无显著情绪
    em_flag_cot_arr = np.zeros(len(em_flag))  # flag计数器
    em_tag = ['angry', 'disgusting', 'fear', 'joy', 'sad']  # 详细的情绪标签
    em_tag_cot_arr = np.zeros(max_dis * len(em_tag)).reshape(max_dis, len(em_tag))
    em_tag_num = np.zeros(max_dis)

    def vector():
        """
        :return: 情绪随半径的变化
        """
        for i in range(len(wbemo_tag)):
            for r in radium:
                r_index = radium.index(r)
                if dis_list[i] <= r:
                    # 在半径为r范围内
                    em_tag_cot_arr[r_index] += np.array(wbemo_tag[i])
                    if np.sum(wbemo_tag[i]) != 0:
                        em_tag_num[r_index] += 1
        res = []
        for i in range(len(radium)):
            # print(em_tag_num)
            em_tag_cot_arr[i] /= em_tag_num[i]
            if mood != 'all':
                tag_index = em_tag.index(mood)
                res.append(em_tag_cot_arr[i][tag_index])
            else:
                res.append(em_tag_cot_arr[i])
        return res

    def value():
        """
        :return: [情绪随半径的变化，flag的总比例向量]
        """
        nonlocal em_flag_cot_arr
        for i in range(len(wbemo_tag)):
            for r in radium:
                r_index = radium.index(r)
                if dis_list[i] <= r:
                    # 在半径为r范围内
                    if wbemo_tag[i][1] != -1:
                        # 单一情绪
                        tag_index = em_tag.index(wbemo_tag[i][1])
                        em_tag_cot_arr[r_index][tag_index] += 1
            flag_index = em_flag.index(wbemo_tag[i][0])
            em_flag_cot_arr[flag_index] += 1
        em_flag_cot_arr /= np.sum(em_flag_cot_arr)
        res = []
        for i in range(len(radium)):
            # print(em_tag_num)
            em_tag_cot_arr[i] /= np.sum(em_tag_cot_arr[i])
            if mood != 'all':
                tag_index = em_tag.index(mood)
                res.append(em_tag_cot_arr[i][tag_index])
            else:
                res.append(em_tag_cot_arr[i])
        return [res, em_flag_cot_arr]

    if method == 'vector':
        return vector
    elif method == 'value':
        return value
```

同理，为方便下文进行画图使用，因此本函数也做成闭包的形式，可以直接在main中调用获取情绪空间分布的信息，也可以用后文提供的封装好的函数在获取信息的同时得到图像。

例——vector法得到的fear随半径变化的趋势：

![vector法得到的fear随半径的变化趋势](D:\大学\大二到大四\大三上\现代程序设计\作业\week3\vector法得到的fear随半径的变化趋势.png)

#### 6. 可视化

使用matplotlib进行可视化分析，分别画出饼图表示总比例以及柱状图和折线图分析变化趋势

```python
def visualization(data, mood, mode, method, timemode=None):
    """
    进行情绪时空间可视化
    :param data: 时间或空间分布数据
    :param mood: 指定情绪
    :param mode: 进行时间(--time)的可视化还是空间(--area)的可视化
    :param timemode: 采用的时间模式hour--0 fixed--1 day--2
    :param method: value或vector
    :return: 无返回值
    """
    em_flag = ['single', 'mixed', 'plain']  # 单一情绪，多情绪混合，无显著情绪
    em_tag = ['angry', 'disgusting', 'fear', 'joy', 'sad']  # 详细的情绪标签
    if timemode != None:
        tm_list = ['hour', 'fixed', 'day']
        tm = tm_list[timemode]
    def draw_pie(data, mode, title):
        """
        画饼图
        :param data: 比例数据
        :param mode: mode == 0,draw tag;elif mode ==1 draw flag
        :param title: str，图片标题
        """
        plt.figure()
        x = data
        if mode == 0:
            labels = em_tag
        elif mode == 1:
            labels = em_flag
        plt.pie(x, labels=labels, autopct='%1.1f%%', shadow=True, startangle=-90)
        plt.title(title)
        plt.legend(loc='upper right', bbox_to_anchor=(1.3, 1))
        plt.savefig('{}.png'.format(title))
        plt.show()

    def draw_bar_and_plot(data, mode, method, title):
        """
        画柱状图和折线图
        :param data: 序列数据
        :param mode: mode ==0,draw bar only; elif mode ==1, draw bar and plot
        :param method: method == 0, time; method == 1 area
        :param title: str，图片标题
        """
        if mode == 0:
            # 柱状图（所有情绪）
            x = np.arange(len(data)) * 5
            tick_label = []
            y1 = []; y2 = []; y3 = []; y4 = []; y5 = []
            cot = 0
            for i in data:
                y1.append(i[0]); y2.append(i[1]);y3.append(i[2])
                y4.append(i[3]); y5.append(i[4])
                if method == 0:
                    tick_label.append("{}-{}h".format(cot, cot + 1))
                elif method == 1:
                    tick_label.append("≤{}km".format(cot + 1))
                cot += 1
            plt.figure(1, figsize=(40, 15))
            bar_width = 0.8
            plt.bar(x, y1, bar_width, label=em_tag[0])
            plt.bar(x + bar_width, y2, bar_width, label=em_tag[1])
            plt.bar(x + 2 * bar_width, y3, bar_width, label=em_tag[2])
            plt.bar(x + 3 * bar_width, y4, bar_width, label=em_tag[3])
            plt.bar(x + 4 * bar_width, y5, bar_width, label=em_tag[4])
            plt.legend(loc='upper right')
            plt.title(title)
            plt.xticks(x + 4 * bar_width / 2, tick_label)
            plt.savefig('{}.png'.format(title))
            plt.show()
        elif mode == 1:
            x = np.arange(len(data))
            y = data
            tick_label = []
            for i in range(len(data)):
                if method == 0:
                    tick_label.append("{}-{}h".format(i, i + 1))
                elif method == 1:
                    tick_label.append("≤{}km".format(i + 1))
            bar_width = 0.5
            plt.figure(2, figsize=(40, 3))
            plt.bar(x, y, bar_width, label=mood)
            plt.legend(loc='upper right')
            plt.title('{}'.format(title))
            plt.xticks(x, tick_label)
            plt.plot(x, y, 'r*-')
            for i in range(len(x)):
                plt.text(x[i], y[i] + 0.01, '{:.2f}'.format(y[i]))
            plt.savefig('{}.png'.format(title))
            plt.show()

    def time():
        nonlocal method
        if method == 'vector':
            # data[0]是tag总比例的向量，data[1]是指定模式的tag比例向量的列表
            # tag总比例的饼图
            draw_pie(data[0], 0, '总时间内向量法各情绪比例分布图')
            # 随时间分布的柱状图或折线图
            if mood == 'all':
                # 柱状图（所有情绪）
                draw_bar_and_plot(data[1], mode=0, method=0, title='向量法情绪比例随时间变化趋势图')
            else:
                # 柱状图+折线图
                draw_bar_and_plot(data[1], mode=1, method=0, title='{}模式下向量法{}情绪比例随时间变化趋势'.format(tm, mood))

        elif method == 'value':
            # data[0]是flag总比例的向量，data[1]是tag总比例的向量，data[2]是指定模式的tag比例向量的列表
            # tag总饼图
            draw_pie(data[1], 0, '总时间内主情绪法各情绪比例分布图')
            # flag总饼图
            draw_pie(data[0], 1, '总时间内主情绪法各情绪分类比例图')
            if mood == 'all':
                # 柱状图（所有情绪）
                draw_bar_and_plot(data[2], mode=0, method=0, title='主情绪法情绪比例随时间变化趋势')
            else:
                # 柱状图+折线图
                draw_bar_and_plot(data[2], mode=1, method=0, title='{}模式下主情绪法{}情绪比例随时间变化趋势'.format(tm, mood))

    def area():
        nonlocal method
        if method == 'vector':
            # data是情绪变量随半径变化的列表
            if mood == 'all':
                # data[-1]是全空间范围内情绪比例
                # tag总比例饼图
                draw_pie(data[-1], mode=0, title='总空间范围内向量法各情绪比例分布图')
                # 多个柱状图
                draw_bar_and_plot(data, mode=0, method=1, title='向量法情绪比例随半径变化趋势')
            else:
                # 柱状图+折线图
                draw_bar_and_plot(data, mode=1, method=1, title='向量法{}情绪比例随半径变化趋势'.format(mood))
        elif method == 'value':
            # data[0]是情绪变量随半径变化的列表，data[1]是大情绪的总空间范围内的比例
            draw_pie(data[1], mode=1, title='总空间范围内主情绪法各情绪种类分布图')
            if mood == 'all':
                # data[0][-1]是情绪变量在全空间范围内的比例
                draw_pie(data[0][-1], mode=0, title='总空间范围内主情绪法各情绪比例图')
                draw_bar_and_plot(data[0], mode=0, method=1, title='主情绪法情绪比例随半径变化趋势')
            else:
                draw_bar_and_plot(data[0], mode=1, method=1, title='主情绪法{}情绪比例随半径变化趋势'.format(mood))


    if mode =='time':
        time()
    elif mode == 'area':
        area()
```

中文字体字号设置、图片分辨率设置：

```python
plt.rcParams['font.family'] = 'SimHei'
plt.rcParams['font.size'] = 12
plt.rcParams['figure.dpi'] = 300
```

部分图片展示：

![总时间内主情绪法各情绪比例分布图](D:\大学\大二到大四\大三上\现代程序设计\作业\week3\总时间内主情绪法各情绪比例分布图.png)

![向量法情绪比例随时间变化趋势图](D:\大学\大二到大四\大三上\现代程序设计\作业\week3\向量法情绪比例随时间变化趋势图.png)

![hour模式下向量法joy情绪比例随时间变化趋势](D:\大学\大二到大四\大三上\现代程序设计\作业\week3\hour模式下向量法joy情绪比例随时间变化趋势.png)

![fixed模式下向量法joy情绪比例随时间变化趋势](D:\大学\大二到大四\大三上\现代程序设计\作业\week3\fixed模式下向量法joy情绪比例随时间变化趋势.png)

![day模式下向量法joy情绪比例随时间变化趋势](D:\大学\大二到大四\大三上\现代程序设计\作业\week3\day模式下向量法joy情绪比例随时间变化趋势.png)

#### 7. 封装的时间和空间情感分析函数

```python
def time_variation(wb_data, filteredwords, mood, mode, method, plt):
    """
    进行情绪随时间变化趋势的分析
    :param wb_data: 微博元数据
    :param filteredwords: 微博分词数据
    :param mood: 指定情绪：'angry' 'disgusting' 'fear' 'joy' 'sad' 'all'
    :param mode: 控制返回时间的模式，包括小时(hour--0)、固定时段(fixed--1)、天(day--2)等
    :param method: 情绪计量的方式 'vector'或'value'
    :param plt: 是否画图，True or False
    :return:
    """
    time_list = extract_time(wb_data)
    wbemo_tag = emotion_tagging(filteredwords, method)
    time_analysis = emotion_time_distribute(wbemo_tag, time_list, mood, timemode=mode, method=method)
    result = time_analysis()
    if plt:
        # 画图
        visualization(result, mood, mode='time', method=method, timemode=mode)
    return result
```

```python
def area_variation(wb_data, filteredwords, mood, method, plt):
    """
    进行情绪随空间变化的分析
    :param wb_data: 微博元数据
    :param filteredwords: 微博分词数据
    :param mood: 指定情绪：'angry' 'disgusting' 'fear' 'joy' 'sad' 'all'
    :param method: 情绪计量的方式 'vector'或'value'
    :param plt: 是否画图，True or False
    :return:
    """
    location_list = extract_area(wb_data)
    wbemo_tag = emotion_tagging(filteredwords, method)
    area_analysis = emotion_location_distribute(wbemo_tag, location_list, mood, method)
    result = area_analysis()
    if plt:
        visualization(result, mood, 'area', method)
    return result
```

#### 8. （可选的）main函数

```python
def main():
    wb_data = load_data('weibo.txt')

    sw_data = load_data('stopwords.txt', 1)
    if " " not in sw_data:
        sw_data += [' ']
    if "\n" not in sw_data:
        sw_data += ['\n']
    if "\t" not in sw_data:
        sw_data += ['\t']

    filteredwords = clean(wb_data, sw_data)
    # wb_value_tag = emotion_tagging(filteredwords, 'value')
    # wb_vector_tag = emotion_tagging(filteredwords, 'vector')

    # time_list = extract_time(wb_data)
    x = time_variation(wb_data, filteredwords, 'angry', 2, 'value', True)
    # print(x[1])

    # location_list = extract_area(wb_data)
    # y = area_variation(wb_data, filteredwords, 'fear', 'vector', False)
    # print(y)
```

### 三、 讨论问题

#### 1. 讨论字典方法进行情绪理解的优缺点，有无可能进一步扩充字典来提高情绪识别的准确率？

字典方法进行情绪理解的优点在于方法简单，分析迅速，对机器的性能要求不高；

缺点则是：

- 强依赖于字典，字典若有问题则分析不准确
- 以字典进行推断，无法推断隐喻等语义，准确率低
- 依赖于分词的手段和噪声的过滤，若分词手段较差，也会影响准确率
- 统计、完善字典前期工作量大

扩充词典在一定程度上可以提高情绪识别的准确率，但这种识别方式的准确率有一个极限，因为它很可能无法处理使用隐喻、反讽等语句的情感分析。

此外，根据参考文献的查阅，我得知，在NLP领域中，最基础的方式就是通过语料库进行研究，本次作业采用的情绪字典方式其实就是语料库分析的简化版，因此，最直接的升级方法就是采用语料库进行分析，其大量的数据可以大大提高识别准确性；但是仅有语料数据是不够的，还可以应用自动机和其他统计技术甚至深度神经网络等技术来进行词法分析、句法分析、词义分析，由此进一步提高识别准确率，但由此一来程序会变得更复杂，对运行环境的要求也会更高

#### 2. 思考情绪时空模式的管理意义？

通过观察一下几组图片进行分析：

**第一组：使用向量法计量情绪，对比不同时间模式joy情绪的变化趋势**

![hour模式下向量法joy情绪比例随时间变化趋势](D:\大学\大二到大四\大三上\现代程序设计\作业\week3\hour模式下向量法joy情绪比例随时间变化趋势.png)

![fixed模式下向量法joy情绪比例随时间变化趋势](D:\大学\大二到大四\大三上\现代程序设计\作业\week3\fixed模式下向量法joy情绪比例随时间变化趋势.png)

![day模式下向量法joy情绪比例随时间变化趋势](D:\大学\大二到大四\大三上\现代程序设计\作业\week3\day模式下向量法joy情绪比例随时间变化趋势.png)

由图1可见，在设定的开始时间点后的每小时愉悦心情的变化是波动性的，也可找到最高点和最低点，这里很可能发生了某些事件；通过图2，我们可以找到一天24小时内某种情感的变化规律，从而在进行事件分析的时候，剔除时间段本身对情感的影响；图3由于数据范围较小因此无法看出过多信息，但可以推测，但数据范围足够大时，它可以起到和图1相似的作用。

甚至我们在有足够多的数据时，可以再分析某种情绪的星期模式、周模式、月模式等，来观察情绪的分布规律，从而才能更好的进行分析。

情绪时间分析的用途较为广泛，主要用来分析某个事件/刺激的影响力，包括舆情分析等。比如上面的一组图结合起来看，我们可以通过分析情绪走向来判断何时可能出现舆情，甚至通过机器学习模型学习正常新闻传播后情绪趋势和舆情传播后的情绪趋势，判断是否有舆情出现等。

**第二组：使用向量法计量情绪，在不同范围内的fear情绪变化趋势**

![向量法fear情绪比例随半径变化趋势](D:\大学\大二到大四\大三上\现代程序设计\作业\week3\向量法fear情绪比例随半径变化趋势.png)

通过这张图片可以看出，距离中心1km范围内，博文的fear情绪最高，然后向四周扩散是逐渐减小并趋于平稳。

由此，可以推测，分析情绪的空间变化趋势也有助于确定全国各地发生相应事件的准确性。如，党某地发生火灾时，分析其一定范围内的情绪变化，和正常情况下可能有很大差异，可以就此判断事件的发生；此外，分析情绪的空间变化也有助于国家检测地方治网络安全问题甚至民生问题等，如某地负面情绪相比其他地方比例较高，则可进一步分析导致负面情绪的原因，由此发现问题并尽快解决。

### 四、附录Appendix

#### 1. 参考文献

- [jieba分词官方文档](https://github.com/fxsjy/jieba)
- 正则表达式：[语法](https://www.runoob.com/regexp/regexp-syntax.html)、[在线测试工具](https://c.runoob.com/front-end/854/)
- [时间和日期模块](https://www.runoob.com/python/python-date-time.html)
- [根据经纬度坐标计算距离](https://www.cnblogs.com/andylhc/p/9481636.html))
- matplotlib绘图: [总括](https://baijiahao.baidu.com/s?id=1645640305376517667&wfr=spider&for=pc)、[柱状图](https://www.jianshu.com/p/e8033e25e1aa)、[图例位置控制](https://blog.csdn.net/RobertChenGuangzhi/article/details/49719467)、[输出图片尺寸](https://www.zhihu.com/question/37221233)
- 关于NLP：《统计自然语言处理（第2版）》 宗成庆 著 清华大学出版社

#### 2. 源代码

```python
import jieba
import re
import numpy as np
import time
from geopy.distance import geodesic
from matplotlib import pyplot as plt
plt.rcParams['font.family'] = 'SimHei'
plt.rcParams['font.size'] = 12
plt.rcParams['figure.dpi'] = 300


def load_data(path, mode=0):
    """
    加载本地数据，只读取txt文本
    :param path: 文件相对位置
    :param mode: 加载文件的模式，0表示正常按行读取，1表示读取后的结果每条去掉末尾的换行符，2表示读取为1类型且值为1的字典
    :return: 数据列表
    """
    with open(path, 'r', encoding='utf-8') as f:
        if mode == 0:
            data = f.readlines()
        elif mode == 1:
            data = f.read().split()
        elif mode == 2:
            data1 = f.read().split()
            lis = [1 for i in range(len(data1))]
            data = dict(zip(data1, lis))
        else:
            raise Exception('Error mode')
    return data


def clean(wb_data, sw_data):
    """
    本函数进行微博语句的清洗
    :param wb_data: 微博分词数据
    :param sw_data: 停用词表
    :return:返回清洗后的分词情况
    """

    def cutting(wb_data):
        """
        将微博数据进行分词
        :param wb_data: 微博元数据
        :return: 分词后的二维列表
        """

        def init():
            # 加载情绪词典
            jieba.load_userdict("emotion dict\\anger.txt")
            jieba.load_userdict("emotion dict\\disgust.txt")
            jieba.load_userdict("emotion dict\\fear.txt")
            jieba.load_userdict("emotion dict\\joy.txt")
            jieba.load_userdict("emotion dict\\sadness.txt")

        init()
        split_list = []
        for wb in wb_data:
            split_list += [jieba.lcut(wb)]
        return split_list

    def remove_urls(wb_data):
        """
        去除微博文本中的URL
        :param wb_data: 微博元数据
        :return: 去除url后的微博数据
        """
        temp = []
        for wb in wb_data:
            try:
                end_index = re.search(r'https?://([\w-]+\.)+[\w-]+(/[\w./?%&=]*)?', wb).span()[0]  # 找到url的起始位置
                temp.append(wb[:end_index])
            except AttributeError:
                temp.append(wb)
        return temp

    def filtering(wordlist):
        """
        过滤停用词
        :param wordlist: 一条微博的分词列表
        :return: 过滤停用词后的分词列表
        """
        temp = []
        for i in wordlist:
            if i not in stopwords_list:
                temp += [i]
        # print(temp)
        return temp

    # 初始化数据结构
    split_list_filtered = []
    stopwords_list = sw_data
    wb_no_urls = remove_urls(wb_data)
    split_list = cutting(wb_no_urls)
    for i in split_list:
        y = filtering(i)
        split_list_filtered += [y]
    # print(split_list_filtered)
    return split_list_filtered


def emotion_analysing(method):
    """
    进行情感分析，传入分词后的结果以及使用的情感分析方法，其中每条微博分词后的结果应该是一维列表，
    :param method: method分为"vector"和"value"，对应返回的是情绪值还是情绪向量
    其中在外层函数传入method控制使用的内层函数，在内层函数传入分词结果
    :return:情感分析结果
    """
    anger_dict = load_data("emotion dict\\anger.txt", 2)
    disgust_dict = load_data("emotion dict\\disgust.txt", 2)
    fear_dict = load_data("emotion dict\\fear.txt", 2)
    joy_dict = load_data("emotion dict\\joy.txt", 2)
    sadness_dict = load_data("emotion dict\\sadness.txt", 2)
    # print(anger_dict)

    def vector(wordlist):
        """
        返回情绪向量的方法，情绪向量的构成为 (anger, disgust, fear, joy, sadness)

        :return: 返回情绪向量，表示每个情绪词的个数比例
        """
        num_vec = [0 for i in range(5)]
        for word in wordlist:
            # print(word)
            if word in anger_dict:
                num_vec[0] += anger_dict[word]
            elif word in disgust_dict:
                num_vec[1] += disgust_dict[word]
            elif word in fear_dict:
                num_vec[2] += fear_dict[word]
            elif word in joy_dict:
                num_vec[3] += joy_dict[word]
            elif word in sadness_dict:
                num_vec[4] += sadness_dict[word]
        num_total = sum(num_vec)
        if num_total == 0:
            res = num_vec
        else:
            res = [(i/num_total) for i in num_vec]
        return res

    def value(wordlist):
        """
        返回情绪值（字符串）的方法，情绪向量的构成为 (anger, disgust, fear, joy, sadness)

        :return: 返回情绪向量，表示每个情绪词的个数比例
        """
        rate_vec = vector(wordlist)
        em_flag = ['single', 'mixed', 'plain']  # 单一情绪，多情绪混合，无显著情绪
        em_tag = ['angry', 'disgusting', 'fear', 'joy', 'sad']  # 详细的情绪标签
        if max(rate_vec) == min(rate_vec):
            # 最大和最小相同（已经包括全是0的情况），表示无显著情绪
            res = (em_flag[2], -1)
        elif rate_vec.count(max(rate_vec)) >1 :
            # 出现重复的最大值时，混合情绪
            res = (em_flag[1], -1)
        else:
            # 有独立最大值，单一情绪
            res = (em_flag[0], em_tag[rate_vec.index(max(rate_vec))])
        return res

    if method == 'vector':
        return vector
    elif method == 'value':
        return value


def emotion_tagging(wb_data, method):
    """
    给每条微博数据进行情绪标记
    :param wb_data: 微博数据列表
    :param method: 采用的情绪判定方法，'vector'或'value'
    :return: 返回情绪标记列表
    """
    res = []
    em_analysing = emotion_analysing(method)
    for i in wb_data:
        tag = em_analysing(i)
        res.append(tag)
    return res


def extract_time(wb_data):
    """
    提取时间信息
    :param wb_data: 微博元数据
    :return: 时间戳的列表
    """
    timetick_list = []
    re_str = '(?P<week>\w{3}) (?P<mon>\w{3}) (?P<day>\d+) (?P<time>\d+:\d+:\d+) (?P<zone>\+\d+) (?P<year>\d{4})'
    for wb in wb_data:
        totaltime_str = re.search(re_str, wb)
        timetick_list.append(time.mktime(time.strptime(totaltime_str.group(),"%a %b %d %H:%M:%S %z %Y")))
    return timetick_list


def emotion_time_distribute(wbemo_tag, time_list, mood, timemode, method):
    """
    传入标签列表并制定返回模式，返回对应情绪的指定模式，经分析，微博数据时间分布从2013.10.11零点-2013.10.13零点共两天的时间
    :param wbemo_tag:微博情绪标签列表
    :param mood: 情绪，包括 'angry', 'disgusting', 'fear', 'joy', 'sad', 'all'（输出所有的情绪比例变化趋势）
    :param timemode: 控制返回的模式，包括小时(hour--0)、固定时段(fixed--1)、天(day--2)等
    :param method: 指定计量情绪的方法，'vector' 或 'value'
    :return: 对应情绪的指定模式
    """
    start_str = '2013 Oct 11 00:00:00'  # 开始时间
    end_str = '2013 Oct 13 01:00:00'  # 结束时间
    start_tick = time.mktime(time.strptime(start_str, "%Y %b %d %X"))  # 转换为时间戳
    end_tick = time.mktime(time.strptime(end_str, "%Y %b %d %X"))
    hour_num = int((end_tick - start_tick) // 3600)  # 一共几个小时
    em_flag = ['single', 'mixed', 'plain']  # 单一情绪，多情绪混合，无显著情绪
    em_flag_cot = [0 for i in range(len(em_flag))]  # flag计数器
    em_tag = ['angry', 'disgusting', 'fear', 'joy', 'sad']  # 详细的情绪标签
    em_tag_cot = np.zeros(len(em_tag))
    em_flag_cot_arr = [np.zeros(len(em_flag) * hour_num).reshape((hour_num, len(em_flag))),
                       np.zeros(len(em_flag) * 24).reshape((24, len(em_flag))),
                       np.zeros(len(em_flag) * 3).reshape((3, len(em_flag)))]  # 分别代表3种模式的计数器，3维数组
    em_tag_cot_arr = [np.zeros(len(em_tag) * 49).reshape((49, len(em_tag))),
                       np.zeros(len(em_tag) * 24).reshape((24, len(em_tag))),
                       np.zeros(len(em_tag) * 3).reshape((3, len(em_tag)))]
    em_vecnum_arr = [np.zeros(hour_num), np.zeros(24), np.zeros(3)]  # 每个模式下对应向量的计数器
    em_tagnum = 0  # 计算非零的向量标签总数

    def vector():
        nonlocal em_tag_cot, em_flag_cot, em_tagnum
        for i in range(len(wbemo_tag)):
            # vector计量情绪，只有情绪比例;wbemo_tag是二维列表
            em_tag_cot += np.array(wbemo_tag[i])
            try:
                if timemode == 0:
                    time_index = int((time_list[i] - start_tick) //3600)
                elif timemode == 1:
                    time_index = int(time.strftime("%H", time.localtime(time_list[i])))
                elif timemode == 2:
                    time_index = int((time_list[i] - start_tick) // (3600*24))
                em_tag_cot_arr[timemode][time_index] += np.array(wbemo_tag[i])
                if np.sum(wbemo_tag[i]) != 0:
                    em_vecnum_arr[timemode][time_index] += 1
                    em_tagnum += 1
            except NameError:
                raise Exception('No time_index')
            except IndexError:
                raise Exception('Wrong index')
        em_tag_cot = em_tag_cot / em_tagnum  # 总的情绪比例
        # print(np.sum(em_tag_cot_arr[timemode]))
        # print(np.sum(em_vecnum_arr[timemode]))
        # print(em_tagnum, em_tag_cot)
        try:
            if timemode == 0:
                num_of_index = hour_num
            elif timemode == 1:
                num_of_index = 24
            elif timemode == 2:
                num_of_index = 3
            res = []
            for hour in range(num_of_index):
                em_tag_cot_arr[timemode][hour] /= em_vecnum_arr[timemode][hour]
                if mood != 'all':
                    tag_index = em_tag.index(mood)
                    res.append(em_tag_cot_arr[timemode][hour][tag_index])
                else:
                    res.append(em_tag_cot_arr[timemode][hour])
        except:
            raise Exception('No num_of_index')

        return [em_tag_cot, res]

    def value():
        nonlocal em_tag_cot, em_flag_cot, em_tagnum
        for i in range(len(wbemo_tag)):
            # value计量情绪，只有一个情绪标签;wbemo_tag是元组的列表，元组第0位是em_flag，第1位是em_tag
            flag_index = em_flag.index(wbemo_tag[i][0])
            em_flag_cot[flag_index] += 1
            if wbemo_tag[i][1] != -1:
                # 单一情绪
                tag_index = em_tag.index(wbemo_tag[i][1])
                em_tag_cot[tag_index] += 1
                try:
                    if timemode == 0:
                        time_index = int((time_list[i] - start_tick) // 3600)
                    elif timemode == 1:
                        time_index = int(time.strftime("%H", time.localtime(time_list[i])))
                    elif timemode == 2:
                        time_index = int((time_list[i] - start_tick) // (3600 * 24))
                    em_tag_cot_arr[timemode][time_index][tag_index] += 1
                    # if np.sum(wbemo_tag[i]) != 0:
                    #     em_vecnum_arr[timemode][time_index] += 1
                    #     em_tagnum += 1
                except NameError:
                    raise Exception('No time_index')
                except IndexError:
                    raise Exception('Wrong index')
        em_tag_cot /= np.sum(em_tag_cot)  # 总的单一情绪的情绪比例
        em_flag_cot /= np.sum(em_flag_cot)  # 总的情绪flag的比例
        try:
            if timemode == 0:
                num_of_index = hour_num
            elif timemode == 1:
                num_of_index = 24
            elif timemode == 2:
                num_of_index = 3
            res = []
            for hour in range(num_of_index):
                em_tag_cot_arr[timemode][hour] /= np.sum(em_tag_cot_arr[timemode][hour])
                if mood != 'all':
                    tag_index = em_tag.index(mood)
                    res.append(em_tag_cot_arr[timemode][hour][tag_index])
                else:
                    res.append(em_tag_cot_arr[timemode][hour])
        except:
            raise Exception('No num_of_index')
        return [em_flag_cot, em_tag_cot, res]

    if method == 'vector':
        return vector
    elif method == 'value':
        return value


def extract_area(wb_data):
    """
    提取地点信息
    :param wb_data: 微博元数据
    :return: 地点信息
    """
    location_list = []
    re_str = '\[(?P<lat>\d.*), (?P<lng>\d.*)\]'  # lat纬度, lng经度
    for wb in wb_data:
        r = re.search(re_str, wb)
        lat = eval(r.group('lat'))
        lng = eval(r.group('lng'))
        location_list.append((lat, lng))
    return location_list


def emotion_location_distribute(wbemo_tag, area_list, mood, method):
    """
    传入标签列表和坐标列表并返回情绪比例随与中心点距离变化的趋势
    :param wbemo_tag: 情绪标签列表
    :param area_list: 坐标元组列表
    :param mood: 指定的情绪
    :param method: 情绪计量的方式
    :return: 情绪比例随与中心点距离变化的趋势
    """
    # 经考察，本微博数据的地点范围主要在北京市范围内，因此以北京市的故宫博物院的位置作为中心点
    center_location = (39.924055, 116.403424) # 纬度，经度
    dis_list = []
    for i in range(len(wbemo_tag)):
        dis = geodesic(center_location, area_list[i]).km
        dis_list.append(dis)
    max_dis = int(max(dis_list)) +1  # 最远距离
    radium = [i for i in range(1, max_dis+1)]
    em_flag = ['single', 'mixed', 'plain']  # 单一情绪，多情绪混合，无显著情绪
    em_flag_cot_arr = np.zeros(len(em_flag))  # flag计数器
    em_tag = ['angry', 'disgusting', 'fear', 'joy', 'sad']  # 详细的情绪标签
    em_tag_cot_arr = np.zeros(max_dis * len(em_tag)).reshape(max_dis, len(em_tag))
    em_tag_num = np.zeros(max_dis)

    def vector():
        """
        :return: 情绪随半径的变化
        """
        for i in range(len(wbemo_tag)):
            for r in radium:
                r_index = radium.index(r)
                if dis_list[i] <= r:
                    # 在半径为r范围内
                    em_tag_cot_arr[r_index] += np.array(wbemo_tag[i])
                    if np.sum(wbemo_tag[i]) != 0:
                        em_tag_num[r_index] += 1
        res = []
        for i in range(len(radium)):
            # print(em_tag_num)
            em_tag_cot_arr[i] /= em_tag_num[i]
            if mood != 'all':
                tag_index = em_tag.index(mood)
                res.append(em_tag_cot_arr[i][tag_index])
            else:
                res.append(em_tag_cot_arr[i])
        return res

    def value():
        """
        :return: [情绪随半径的变化，flag的总比例向量]
        """
        nonlocal em_flag_cot_arr
        for i in range(len(wbemo_tag)):
            for r in radium:
                r_index = radium.index(r)
                if dis_list[i] <= r:
                    # 在半径为r范围内
                    if wbemo_tag[i][1] != -1:
                        # 单一情绪
                        tag_index = em_tag.index(wbemo_tag[i][1])
                        em_tag_cot_arr[r_index][tag_index] += 1
            flag_index = em_flag.index(wbemo_tag[i][0])
            em_flag_cot_arr[flag_index] += 1
        em_flag_cot_arr /= np.sum(em_flag_cot_arr)
        res = []
        for i in range(len(radium)):
            # print(em_tag_num)
            em_tag_cot_arr[i] /= np.sum(em_tag_cot_arr[i])
            if mood != 'all':
                tag_index = em_tag.index(mood)
                res.append(em_tag_cot_arr[i][tag_index])
            else:
                res.append(em_tag_cot_arr[i])
        return [res, em_flag_cot_arr]

    if method == 'vector':
        return vector
    elif method == 'value':
        return value


def visualization(data, mood, mode, method, timemode=None):
    """
    进行情绪时空间可视化
    :param data: 时间或空间分布数据
    :param mood: 指定情绪
    :param mode: 进行时间(--time)的可视化还是空间(--area)的可视化
    :param timemode: 采用的时间模式hour--0 fixed--1 day--2
    :param method: value或vector
    :return: 无返回值
    """
    em_flag = ['single', 'mixed', 'plain']  # 单一情绪，多情绪混合，无显著情绪
    em_tag = ['angry', 'disgusting', 'fear', 'joy', 'sad']  # 详细的情绪标签
    if timemode != None:
        tm_list = ['hour', 'fixed', 'day']
        tm = tm_list[timemode]
    def draw_pie(data, mode, title):
        """
        画饼图
        :param data: 比例数据
        :param mode: mode == 0,draw tag;elif mode ==1 draw flag
        :param title: str，图片标题
        """
        plt.figure()
        x = data
        if mode == 0:
            labels = em_tag
        elif mode == 1:
            labels = em_flag
        plt.pie(x, labels=labels, autopct='%1.1f%%', shadow=True, startangle=-90)
        plt.title(title)
        plt.legend(loc='upper right', bbox_to_anchor=(1.3, 1))
        plt.savefig('{}.png'.format(title))
        plt.show()

    def draw_bar_and_plot(data, mode, method, title):
        """
        画柱状图和折线图
        :param data: 序列数据
        :param mode: mode ==0,draw bar only; elif mode ==1, draw bar and plot
        :param method: method == 0, time; method == 1 area
        :param title: str，图片标题
        """
        if mode == 0:
            # 柱状图（所有情绪）
            x = np.arange(len(data)) * 5
            tick_label = []
            y1 = []; y2 = []; y3 = []; y4 = []; y5 = []
            cot = 0
            for i in data:
                y1.append(i[0]); y2.append(i[1]);y3.append(i[2])
                y4.append(i[3]); y5.append(i[4])
                if method == 0:
                    tick_label.append("{}-{}h".format(cot, cot + 1))
                elif method == 1:
                    tick_label.append("≤{}km".format(cot + 1))
                cot += 1
            plt.figure(1, figsize=(40, 15))
            bar_width = 0.8
            plt.bar(x, y1, bar_width, label=em_tag[0])
            plt.bar(x + bar_width, y2, bar_width, label=em_tag[1])
            plt.bar(x + 2 * bar_width, y3, bar_width, label=em_tag[2])
            plt.bar(x + 3 * bar_width, y4, bar_width, label=em_tag[3])
            plt.bar(x + 4 * bar_width, y5, bar_width, label=em_tag[4])
            plt.legend(loc='upper right')
            plt.title(title)
            plt.xticks(x + 4 * bar_width / 2, tick_label)
            plt.savefig('{}.png'.format(title))
            plt.show()
        elif mode == 1:
            x = np.arange(len(data))
            y = data
            tick_label = []
            for i in range(len(data)):
                if method == 0:
                    tick_label.append("{}-{}h".format(i, i + 1))
                elif method == 1:
                    tick_label.append("≤{}km".format(i + 1))
            bar_width = 0.5
            plt.figure(2, figsize=(40, 3))
            plt.bar(x, y, bar_width, label=mood)
            plt.legend(loc='upper right')
            plt.title('{}'.format(title))
            plt.xticks(x, tick_label)
            plt.plot(x, y, 'r*-')
            for i in range(len(x)):
                plt.text(x[i], y[i] + 0.01, '{:.2f}'.format(y[i]))
            plt.savefig('{}.png'.format(title))
            plt.show()

    def time():
        nonlocal method
        if method == 'vector':
            # data[0]是tag总比例的向量，data[1]是指定模式的tag比例向量的列表
            # tag总比例的饼图
            draw_pie(data[0], 0, '总时间内向量法各情绪比例分布图')
            # 随时间分布的柱状图或折线图
            if mood == 'all':
                # 柱状图（所有情绪）
                draw_bar_and_plot(data[1], mode=0, method=0, title='向量法情绪比例随时间变化趋势图')
            else:
                # 柱状图+折线图
                draw_bar_and_plot(data[1], mode=1, method=0, title='{}模式下向量法{}情绪比例随时间变化趋势'.format(tm, mood))

        elif method == 'value':
            # data[0]是flag总比例的向量，data[1]是tag总比例的向量，data[2]是指定模式的tag比例向量的列表
            # tag总饼图
            draw_pie(data[1], 0, '总时间内主情绪法各情绪比例分布图')
            # flag总饼图
            draw_pie(data[0], 1, '总时间内主情绪法各情绪分类比例图')
            if mood == 'all':
                # 柱状图（所有情绪）
                draw_bar_and_plot(data[2], mode=0, method=0, title='主情绪法情绪比例随时间变化趋势')
            else:
                # 柱状图+折线图
                draw_bar_and_plot(data[2], mode=1, method=0, title='{}模式下主情绪法{}情绪比例随时间变化趋势'.format(tm, mood))

    def area():
        nonlocal method
        if method == 'vector':
            # data是情绪变量随半径变化的列表
            if mood == 'all':
                # data[-1]是全空间范围内情绪比例
                # tag总比例饼图
                draw_pie(data[-1], mode=0, title='总空间范围内向量法各情绪比例分布图')
                # 多个柱状图
                draw_bar_and_plot(data, mode=0, method=1, title='向量法情绪比例随半径变化趋势')
            else:
                # 柱状图+折线图
                draw_bar_and_plot(data, mode=1, method=1, title='向量法{}情绪比例随半径变化趋势'.format(mood))
        elif method == 'value':
            # data[0]是情绪变量随半径变化的列表，data[1]是大情绪的总空间范围内的比例
            draw_pie(data[1], mode=1, title='总空间范围内主情绪法各情绪种类分布图')
            if mood == 'all':
                # data[0][-1]是情绪变量在全空间范围内的比例
                draw_pie(data[0][-1], mode=0, title='总空间范围内主情绪法各情绪比例图')
                draw_bar_and_plot(data[0], mode=0, method=1, title='主情绪法情绪比例随半径变化趋势')
            else:
                draw_bar_and_plot(data[0], mode=1, method=1, title='主情绪法{}情绪比例随半径变化趋势'.format(mood))


    if mode =='time':
        time()
    elif mode == 'area':
        area()


def time_variation(wb_data, filteredwords, mood, mode, method, plt):
    """
    进行情绪随时间变化趋势的分析
    :param wb_data: 微博元数据
    :param filteredwords: 微博分词数据
    :param mood: 指定情绪：'angry' 'disgusting' 'fear' 'joy' 'sad' 'all'
    :param mode: 控制返回时间的模式，包括小时(hour--0)、固定时段(fixed--1)、天(day--2)等
    :param method: 情绪计量的方式 'vector'或'value'
    :param plt: 是否画图，True or False
    :return:
    """
    time_list = extract_time(wb_data)
    wbemo_tag = emotion_tagging(filteredwords, method)
    time_analysis = emotion_time_distribute(wbemo_tag, time_list, mood, timemode=mode, method=method)
    result = time_analysis()
    if plt:
        # 画图
        visualization(result, mood, mode='time', method=method, timemode=mode)
    return result


def area_variation(wb_data, filteredwords, mood, method, plt):
    """
    进行情绪随空间变化的分析
    :param wb_data: 微博元数据
    :param filteredwords: 微博分词数据
    :param mood: 指定情绪：'angry' 'disgusting' 'fear' 'joy' 'sad' 'all'
    :param method: 情绪计量的方式 'vector'或'value'
    :param plt: 是否画图，True or False
    :return:
    """
    location_list = extract_area(wb_data)
    wbemo_tag = emotion_tagging(filteredwords, method)
    area_analysis = emotion_location_distribute(wbemo_tag, location_list, mood, method)
    result = area_analysis()
    if plt:
        visualization(result, mood, 'area', method)
    return result


def main():
    wb_data = load_data('weibo.txt')

    sw_data = load_data('stopwords.txt', 1)
    if " " not in sw_data:
        sw_data += [' ']
    if "\n" not in sw_data:
        sw_data += ['\n']
    if "\t" not in sw_data:
        sw_data += ['\t']

    filteredwords = clean(wb_data, sw_data)
    # wb_value_tag = emotion_tagging(filteredwords, 'value')
    # wb_vector_tag = emotion_tagging(filteredwords, 'vector')

    # time_list = extract_time(wb_data)
    x = time_variation(wb_data, filteredwords, 'angry', 2, 'value', True)
    # print(x[1])

    # location_list = extract_area(wb_data)
    # y = area_variation(wb_data, filteredwords, 'fear', 'vector', False)
    # print(y)


if __name__ == "__main__":
    main()

```
